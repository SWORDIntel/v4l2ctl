#!/usr/bin/env python3
"""
DSV4L2 Exploit Pattern Detector

ML-based crash analysis and exploit classification for zero-day discovery.
Analyzes crash dumps, stack traces, and memory patterns to identify
exploitable vulnerabilities.

Classification Categories:
- Heap corruption (buffer overflow, use-after-free, double-free)
- Stack corruption (buffer overflow, stack pivot)
- Integer overflow/underflow
- Format string vulnerabilities
- Null pointer dereference
- Uninitialized memory read
- Type confusion
- Logic errors

Exploitability Ratings:
- CRITICAL: Likely exploitable for code execution
- HIGH: Potentially exploitable with additional work
- MEDIUM: Denial-of-service, limited exploitation
- LOW: Crash with no clear exploit path
- INFO: Expected behavior or benign crash
"""

import os
import sys
import re
import json
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from enum import Enum


class ExploitCategory(Enum):
    """Vulnerability categories"""
    HEAP_CORRUPTION = "heap_corruption"
    STACK_CORRUPTION = "stack_corruption"
    INTEGER_OVERFLOW = "integer_overflow"
    FORMAT_STRING = "format_string"
    NULL_DEREF = "null_dereference"
    UNINIT_READ = "uninitialized_read"
    TYPE_CONFUSION = "type_confusion"
    LOGIC_ERROR = "logic_error"
    UNKNOWN = "unknown"


class ExploitSeverity(Enum):
    """Exploitability severity ratings"""
    CRITICAL = "critical"  # RCE likely
    HIGH = "high"          # Potentially exploitable
    MEDIUM = "medium"      # DoS, limited exploitation
    LOW = "low"            # Crash, no clear path
    INFO = "info"          # Benign


@dataclass
class CrashAnalysis:
    """Analysis results for a crash"""
    crash_file: str
    category: ExploitCategory
    severity: ExploitSeverity
    signal: str
    description: str
    stack_trace: List[str]
    crash_offset: Optional[int] = None
    faulting_address: Optional[str] = None
    exploitability_score: float = 0.0
    recommendations: List[str] = None


class ExploitDetector:
    """Exploit pattern detector and crash analyzer"""

    def __init__(self, gdb_path: str = "gdb"):
        """
        Initialize exploit detector

        Args:
            gdb_path: Path to GDB debugger
        """
        self.gdb_path = gdb_path

        # Heap corruption patterns
        self.heap_patterns = [
            (r"free\(\): invalid pointer", ExploitCategory.HEAP_CORRUPTION, ExploitSeverity.HIGH),
            (r"double free", ExploitCategory.HEAP_CORRUPTION, ExploitSeverity.CRITICAL),
            (r"corrupted size vs\. prev_size", ExploitCategory.HEAP_CORRUPTION, ExploitSeverity.CRITICAL),
            (r"malloc\(\): memory corruption", ExploitCategory.HEAP_CORRUPTION, ExploitSeverity.CRITICAL),
            (r"free\(\): invalid next size", ExploitCategory.HEAP_CORRUPTION, ExploitSeverity.HIGH),
        ]

        # Stack corruption patterns
        self.stack_patterns = [
            (r"stack smashing detected", ExploitCategory.STACK_CORRUPTION, ExploitSeverity.CRITICAL),
            (r"__stack_chk_fail", ExploitCategory.STACK_CORRUPTION, ExploitSeverity.CRITICAL),
            (r"stack overflow", ExploitCategory.STACK_CORRUPTION, ExploitSeverity.HIGH),
        ]

        # Other vulnerability patterns
        self.other_patterns = [
            (r"division by zero", ExploitCategory.INTEGER_OVERFLOW, ExploitSeverity.LOW),
            (r"integer overflow", ExploitCategory.INTEGER_OVERFLOW, ExploitSeverity.MEDIUM),
            (r"format string", ExploitCategory.FORMAT_STRING, ExploitSeverity.CRITICAL),
            (r"null pointer dereference", ExploitCategory.NULL_DEREF, ExploitSeverity.LOW),
            (r"uninitialized value", ExploitCategory.UNINIT_READ, ExploitSeverity.MEDIUM),
        ]

    def analyze_crash(self, crash_file: Path, binary: str) -> CrashAnalysis:
        """
        Analyze a crash file and classify the vulnerability

        Args:
            crash_file: Path to crashing input
            binary: Path to fuzzing target binary

        Returns:
            CrashAnalysis with classification and recommendations
        """
        # Reproduce crash with GDB
        gdb_output = self._run_gdb(binary, crash_file)

        # Extract crash information
        signal = self._extract_signal(gdb_output)
        stack_trace = self._extract_stack_trace(gdb_output)
        faulting_addr = self._extract_faulting_address(gdb_output)

        # Classify vulnerability
        category, severity = self._classify_crash(gdb_output, signal)

        # Generate description
        description = self._generate_description(category, severity, signal, faulting_addr)

        # Calculate exploitability score
        exploit_score = self._calculate_exploitability(category, severity, stack_trace, gdb_output)

        # Generate recommendations
        recommendations = self._generate_recommendations(category, severity)

        return CrashAnalysis(
            crash_file=str(crash_file),
            category=category,
            severity=severity,
            signal=signal,
            description=description,
            stack_trace=stack_trace,
            faulting_address=faulting_addr,
            exploitability_score=exploit_score,
            recommendations=recommendations
        )

    def _run_gdb(self, binary: str, crash_file: Path) -> str:
        """
        Run crash input through GDB and capture output

        Args:
            binary: Path to binary
            crash_file: Path to crashing input

        Returns:
            GDB output as string
        """
        gdb_commands = f"""
        set pagination off
        set confirm off
        run {crash_file}
        bt
        info registers
        x/16x $rsp
        quit
        """

        try:
            result = subprocess.run(
                [self.gdb_path, "-batch", "-ex", gdb_commands, binary],
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.stdout + result.stderr
        except subprocess.TimeoutExpired:
            return "GDB timeout"
        except Exception as e:
            return f"GDB error: {e}"

    def _extract_signal(self, gdb_output: str) -> str:
        """Extract crash signal from GDB output"""
        patterns = [
            r"Program received signal (\w+)",
            r"Signal: (\w+)",
        ]

        for pattern in patterns:
            match = re.search(pattern, gdb_output)
            if match:
                return match.group(1)

        return "UNKNOWN"

    def _extract_stack_trace(self, gdb_output: str) -> List[str]:
        """Extract stack trace from GDB output"""
        stack_trace = []

        # Find backtrace section
        in_backtrace = False
        for line in gdb_output.split('\n'):
            if 'backtrace' in line.lower() or line.startswith('#'):
                in_backtrace = True

            if in_backtrace and line.startswith('#'):
                stack_trace.append(line.strip())

            if in_backtrace and line.strip() == '':
                break

        return stack_trace[:20]  # Limit to 20 frames

    def _extract_faulting_address(self, gdb_output: str) -> Optional[str]:
        """Extract faulting memory address"""
        patterns = [
            r"at address (0x[0-9a-fA-F]+)",
            r"Cannot access memory at address (0x[0-9a-fA-F]+)",
        ]

        for pattern in patterns:
            match = re.search(pattern, gdb_output)
            if match:
                return match.group(1)

        return None

    def _classify_crash(self, gdb_output: str, signal: str) -> Tuple[ExploitCategory, ExploitSeverity]:
        """
        Classify crash based on patterns and signal

        Returns:
            (category, severity) tuple
        """
        # Check heap corruption patterns
        for pattern, category, severity in self.heap_patterns:
            if re.search(pattern, gdb_output, re.IGNORECASE):
                return category, severity

        # Check stack corruption patterns
        for pattern, category, severity in self.stack_patterns:
            if re.search(pattern, gdb_output, re.IGNORECASE):
                return category, severity

        # Check other patterns
        for pattern, category, severity in self.other_patterns:
            if re.search(pattern, gdb_output, re.IGNORECASE):
                return category, severity

        # Classify by signal
        if signal == "SIGSEGV":
            return ExploitCategory.NULL_DEREF, ExploitSeverity.MEDIUM
        elif signal == "SIGABRT":
            return ExploitCategory.HEAP_CORRUPTION, ExploitSeverity.HIGH
        elif signal == "SIGFPE":
            return ExploitCategory.INTEGER_OVERFLOW, ExploitSeverity.LOW
        elif signal == "SIGILL":
            return ExploitCategory.TYPE_CONFUSION, ExploitSeverity.MEDIUM

        return ExploitCategory.UNKNOWN, ExploitSeverity.LOW

    def _calculate_exploitability(self,
                                   category: ExploitCategory,
                                   severity: ExploitSeverity,
                                   stack_trace: List[str],
                                   gdb_output: str) -> float:
        """
        Calculate exploitability score (0.0 - 1.0)

        Factors:
        - Vulnerability category (heap > stack > others)
        - Control of crash location
        - Stack trace depth
        - Presence of security mitigations
        """
        score = 0.0

        # Base score by category
        category_scores = {
            ExploitCategory.HEAP_CORRUPTION: 0.8,
            ExploitCategory.STACK_CORRUPTION: 0.9,
            ExploitCategory.FORMAT_STRING: 1.0,
            ExploitCategory.INTEGER_OVERFLOW: 0.5,
            ExploitCategory.TYPE_CONFUSION: 0.7,
            ExploitCategory.NULL_DEREF: 0.2,
            ExploitCategory.UNINIT_READ: 0.3,
            ExploitCategory.LOGIC_ERROR: 0.3,
            ExploitCategory.UNKNOWN: 0.1,
        }
        score += category_scores.get(category, 0.0)

        # Severity adjustment
        severity_multipliers = {
            ExploitSeverity.CRITICAL: 1.0,
            ExploitSeverity.HIGH: 0.8,
            ExploitSeverity.MEDIUM: 0.5,
            ExploitSeverity.LOW: 0.3,
            ExploitSeverity.INFO: 0.1,
        }
        score *= severity_multipliers.get(severity, 0.5)

        # Check for security mitigations (reduces exploitability)
        if "ASLR enabled" in gdb_output or "PIE enabled" in gdb_output:
            score *= 0.7
        if "Stack canary" in gdb_output or "__stack_chk" in gdb_output:
            score *= 0.8
        if "NX enabled" in gdb_output or "DEP enabled" in gdb_output:
            score *= 0.9

        return min(score, 1.0)

    def _generate_description(self,
                              category: ExploitCategory,
                              severity: ExploitSeverity,
                              signal: str,
                              faulting_addr: Optional[str]) -> str:
        """Generate human-readable crash description"""
        descriptions = {
            ExploitCategory.HEAP_CORRUPTION: "Heap corruption detected - potential memory safety violation",
            ExploitCategory.STACK_CORRUPTION: "Stack corruption detected - buffer overflow likely",
            ExploitCategory.INTEGER_OVERFLOW: "Integer overflow/underflow detected",
            ExploitCategory.FORMAT_STRING: "Format string vulnerability detected",
            ExploitCategory.NULL_DEREF: "Null pointer dereference",
            ExploitCategory.UNINIT_READ: "Uninitialized memory read",
            ExploitCategory.TYPE_CONFUSION: "Type confusion or invalid memory access",
            ExploitCategory.LOGIC_ERROR: "Logic error leading to crash",
            ExploitCategory.UNKNOWN: f"Crash with signal {signal}",
        }

        desc = descriptions.get(category, "Unknown crash type")

        if faulting_addr:
            desc += f" at address {faulting_addr}"

        desc += f" (Severity: {severity.value.upper()})"

        return desc

    def _generate_recommendations(self,
                                   category: ExploitCategory,
                                   severity: ExploitSeverity) -> List[str]:
        """Generate remediation recommendations"""
        recommendations = []

        if category == ExploitCategory.HEAP_CORRUPTION:
            recommendations.append("Add bounds checking before heap allocations")
            recommendations.append("Validate free() arguments are valid pointers")
            recommendations.append("Consider using memory-safe allocators (tcmalloc, jemalloc)")
            recommendations.append("Run with AddressSanitizer (ASAN) for detailed heap analysis")

        elif category == ExploitCategory.STACK_CORRUPTION:
            recommendations.append("Add bounds checking for buffer operations")
            recommendations.append("Use safe string functions (strncpy, snprintf)")
            recommendations.append("Enable stack canaries (-fstack-protector-all)")
            recommendations.append("Verify all array accesses are within bounds")

        elif category == ExploitCategory.INTEGER_OVERFLOW:
            recommendations.append("Add overflow checks before arithmetic operations")
            recommendations.append("Use safe integer libraries")
            recommendations.append("Compile with -ftrapv or UndefinedBehaviorSanitizer")

        elif category == ExploitCategory.NULL_DEREF:
            recommendations.append("Add null pointer checks before dereferencing")
            recommendations.append("Initialize all pointers to NULL")
            recommendations.append("Validate function return values")

        # General recommendations
        if severity in [ExploitSeverity.CRITICAL, ExploitSeverity.HIGH]:
            recommendations.append("PRIORITY: Fix immediately - high exploitability")
            recommendations.append("Add regression test with crashing input")
            recommendations.append("Consider CVE assignment if in released code")

        return recommendations

    def analyze_directory(self, crash_dir: Path, binary: str, output_file: Optional[str] = None) -> List[CrashAnalysis]:
        """
        Analyze all crashes in a directory

        Args:
            crash_dir: Directory containing crash files
            binary: Path to fuzzing target
            output_file: Optional JSON output file

        Returns:
            List of crash analyses
        """
        analyses = []

        crash_files = list(crash_dir.glob("*.bin"))
        print(f"Analyzing {len(crash_files)} crashes...")

        for i, crash_file in enumerate(crash_files, 1):
            print(f"  [{i}/{len(crash_files)}] {crash_file.name}...")

            try:
                analysis = self.analyze_crash(crash_file, binary)
                analyses.append(analysis)

                # Print immediate results
                print(f"    Category: {analysis.category.value}")
                print(f"    Severity: {analysis.severity.value.upper()}")
                print(f"    Exploitability: {analysis.exploitability_score:.2f}")

            except Exception as e:
                print(f"    Error: {e}")

        # Sort by exploitability score
        analyses.sort(key=lambda x: x.exploitability_score, reverse=True)

        # Export to JSON
        if output_file:
            with open(output_file, 'w') as f:
                json.dump([asdict(a) for a in analyses], f, indent=2, default=str)
            print(f"\nResults exported to: {output_file}")

        return analyses


def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description="DSV4L2 Exploit Pattern Detector")
    parser.add_argument("binary", help="Path to fuzzing target binary")
    parser.add_argument("crashes", help="Directory containing crash files")
    parser.add_argument("-o", "--output", help="JSON output file")
    parser.add_argument("--gdb", default="gdb", help="Path to GDB")

    args = parser.parse_args()

    # Validate inputs
    if not os.path.exists(args.binary):
        print(f"Error: Binary not found: {args.binary}")
        return 1

    crash_dir = Path(args.crashes)
    if not crash_dir.is_dir():
        print(f"Error: Crash directory not found: {args.crashes}")
        return 1

    # Create detector
    detector = ExploitDetector(gdb_path=args.gdb)

    # Analyze crashes
    analyses = detector.analyze_directory(crash_dir, args.binary, args.output)

    # Print summary
    print()
    print("=" * 80)
    print("Exploit Analysis Summary")
    print("=" * 80)

    if not analyses:
        print("No crashes analyzed")
        return 0

    # Group by severity
    by_severity = {}
    for analysis in analyses:
        severity = analysis.severity.value
        by_severity.setdefault(severity, []).append(analysis)

    for severity in ["critical", "high", "medium", "low", "info"]:
        count = len(by_severity.get(severity, []))
        if count > 0:
            print(f"{severity.upper()}: {count}")

    # Show top exploitable crashes
    print()
    print("Top 5 Exploitable Crashes:")
    for i, analysis in enumerate(analyses[:5], 1):
        print(f"\n{i}. {Path(analysis.crash_file).name}")
        print(f"   Category: {analysis.category.value}")
        print(f"   Severity: {analysis.severity.value.upper()}")
        print(f"   Exploitability: {analysis.exploitability_score:.2f}")
        print(f"   {analysis.description}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
